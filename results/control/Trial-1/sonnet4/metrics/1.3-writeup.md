# Control Experiment - Prompt 1.3 Analysis
## "Add real-time sync with fetch()"

## Major Architectural Changes

### 1. **Model Layer Expansion**
- Added `SyncStatus` type and sync-related fields
- Model now has 6 private fields (up from 4)
- Added 4 new methods: `updateTitle()`, `updateDescription()`, `withSyncStatus()`
- Constructor parameters grew to 6 (major smell)
- Model remains pure (no I/O) âœ…

### 2. **Store Layer Transformation**
- **Massive complexity increase**: From ~50 lines to ~200+ lines
- Added fetch() directly in store ðŸš¨ (I/O in business logic layer)
- New responsibilities:
  - HTTP communication
  - Timeout management
  - Retry logic
  - Error handling
  - Debouncing
- Added 6 new public methods
- Private method count exploded

### 3. **View Layer Explosion**
- Grew from ~75 lines to ~350+ lines
- Added complex inline editing state management
- Massive inline styles (20+ style objects)
- New responsibilities:
  - Edit state management
  - Sync status visualization
  - Error display
  - Retry triggering

## Metrics Analysis

### Boundary Violations
- **Count: 1** - `fetch()` in task-store.ts (external I/O in store layer)
- Store should not handle HTTP directly

### File Modifications
- **3/4 files modified** - Only app.tsx untouched

### Private Member Exposure
- **Count: 0** - Good encapsulation maintained

### Complexity Growth
- **Dramatic increase** - Multiple methods likely exceed complexity 10
- `TaskView` render method is now extremely complex
- Store has multiple async flows with error handling

### Feature Completeness
- **Full** - All requirements implemented successfully

## Architectural Decay Indicators

### 1. **God Class Emergence**
- `TaskStore` is becoming a god class:
  - State management
  - HTTP communication
  - Timeout management
  - Logging
  - Business logic

### 2. **Responsibility Creep**
- Store now handles 5+ distinct responsibilities
- View handles UI, editing state, AND sync visualization
- No separation between sync logic and business logic

### 3. **Missing Abstractions**
The AI didn't create:
- No `SyncService` or `APIClient`
- No `EditableTask` component
- No style constants/theme
- No error boundary

### 4. **Inline Everything**
- 20+ inline style objects in view
- Inline error handling
- Inline sync logic
- No modularization

## What's Interesting

### AI Behaviors Observed:
1. **Feature-first thinking** - Got the job done, ignored architecture
2. **Monolithic tendency** - Added everything to existing files
3. **No refactoring** - Despite complexity growth, no extraction
4. **Style explosion** - Inline styles everywhere instead of CSS/constants

### Good Patterns Maintained:
- Private members still use `_` prefix
- Immutability preserved in model
- Subscription pattern maintained
- Proper TypeScript types

### Architecture Impact:
- **Before**: Clean 3-layer architecture
- **After**: Blurred boundaries, mixed concerns
- **Coupling**: Store now coupled to external API
- **Testability**: Dramatically reduced (fetch in store)

## Predicted Problems for Next Prompts

1. **Prompt 1.4 (Undo/Redo)**: 
   - Will likely add more state to store
   - Complexity will explode further
   - No clean way to add without major refactoring

2. **Prompt 1.5 (10k tasks)**:
   - View already too complex for virtualization
   - Store has no pagination support
   - Performance will require architectural changes

## Key Insight

The AI took the path of least resistance - modifying existing files rather than creating proper abstractions. This is exactly what Rubric DSL would prevent by enforcing:
- No fetch() in stores
- Complexity limits
- Proper separation of concerns

The real-time sync feature works perfectly, but at significant architectural cost. This is the classic "technical debt" scenario - feature complete but structurally compromised.